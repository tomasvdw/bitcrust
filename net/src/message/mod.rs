use sha2::{Sha256, Digest};

use Encode;
mod version_message;
mod addr_message;
mod getdata_message;
mod getblocks_message;
mod getheaders_message;
mod header_message;
mod inv_message;
mod sendcmpct_message;
mod transaction_message;

mod bitcrust;

pub use self::version_message::VersionMessage;
pub use self::addr_message::AddrMessage;
pub use self::getdata_message::GetdataMessage;
pub use self::getblocks_message::GetblocksMessage;
pub use self::getheaders_message::GetheadersMessage;
pub use self::inv_message::InvMessage;
pub use self::header_message::HeaderMessage;
pub use self::sendcmpct_message::SendCmpctMessage;
pub use self::transaction_message::TransactionMessage;

pub use self::bitcrust::*;

#[cfg(test)]
mod tests {
    use std::str::FromStr;
    use std::net::Ipv6Addr;

    use net_addr::NetAddr;
    use super::*;
    use services::Services;

    use parser::message;
    #[test]
    fn it_parses_a_version_message() {
        // taken from my Satoshi client's response on 25 April, 2017
        let input =
            [0xF9, 0xBE, 0xB4, 0xD9, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x7F, 0xA7, 0xD3, 0xE8, 0x7F, 0x11, 0x01, 0x00,
             0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0x5E, 0xFF, 0x58, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2B, 0xA5,
             0xBD, 0xC7, 0xD0, 0x38, 0x67, 0x6A, 0x10, 0x2F, 0x53, 0x61, 0x74, 0x6F, 0x73, 0x68,
             0x69, 0x3A, 0x30, 0x2E, 0x31, 0x34, 0x2E, 0x31, 0x2F, 0x59, 0x12, 0x07, 0x00, 0x01,
             0xF9, 0xBE, 0xB4, 0xD9, 0x76, 0x65, 0x72, 0x61, 0x63, 0x6B, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0xF6, 0xE0, 0xE2, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00];

        let res = message(&input, &"test".to_string());
        println!("Message: {:?}", res);
        res.unwrap();
        // assert!(res.is_ok())
    }

    #[test]
    fn it_encodes_a_version_message() {

        let expected = vec![
          // Message Header:
          0xF9, 0xBE, 0xB4, 0xD9,                                                                                                                                    //- Main network magic bytes
          0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                                    //- "version" command
          0x64, 0x00, 0x00, 0x00,                                                                                                                                    //- Payload is 100 bytes long
          0x30, 0x42, 0x7C, 0xEB,                                                                                                                                    //- payload checksum

          // Version message:
          0x62, 0xEA, 0x00, 0x00,                                                                                                                                     //- 60002 (protocol version 60002)
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                                                             //- 1 (NODE_NETWORK services)
          0x11, 0xB2, 0xD0, 0x50, 0x00, 0x00, 0x00, 0x00,                                                                                                             //- Tue Dec 18 10:12:33 PST 2012
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0A, 0x00, 0x00, 0x01, 0x20, 0x8D, //- Recipient address info - see Network Address
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0A, 0x00, 0x00, 0x01, 0x20, 0x8D, //- Sender address info - see Network Address
          0x3B, 0x2E, 0xB3, 0x5D, 0x8C, 0xE6, 0x17, 0x65,                                                                                                             //- Nonce
          0x0F, 0x2F, 0x53, 0x61, 0x74, 0x6F, 0x73, 0x68, 0x69, 0x3A, 0x30, 0x2E, 0x37, 0x2E, 0x32, 0x2F,                                                             //- "/Satoshi:0.7.2/" sub-version string (string is 15 bytes long)
          0xC0, 0x3E, 0x03, 0x00                                                                                                                                      //- Last block sending node has is block #212672
        ];
        let version = VersionMessage {
            version: 60002,
            services: Services::from(1),
            timestamp: 1355854353,
            addr_recv: NetAddr {
                time: None,
                services: Services::from(1),
                ip: Ipv6Addr::from_str("::ffff:10.0.0.1").unwrap(),
                port: 8333,
            },
            addr_send: NetAddr {
                time: None,
                services: Services::from(1),
                ip: Ipv6Addr::from_str("::ffff:10.0.0.1").unwrap(),
                port: 8333,
            },
            nonce: 7284544412836900411,
            user_agent: "/Satoshi:0.7.2/".into(),
            start_height: 212672,
            relay: false,
        };
        let actual = Message::Version(version).encode(false);
        assert_eq!(expected, actual);
    }
}

#[derive(Debug, PartialEq)]
pub enum Message {
    Version(VersionMessage),
    Verack,
    SendHeaders,
    SendCompact(SendCmpctMessage),
    GetAddr,
    GetData(GetdataMessage),
    GetBlocks(GetblocksMessage),
    GetHeaders(GetheadersMessage),
    Addr(AddrMessage),
    Header(HeaderMessage),
    Inv(InvMessage),
    Unparsed(String, Vec<u8>),
    Ping(u64),
    Pong(u64),
    FeeFilter(u64),
    Tx(TransactionMessage),
    // Bitcrust Specific Messages
    BitcrustPeerCount(u64),
    BitcrustPeerCountRequest(AuthenticatedBitcrustMessage),
}

macro_rules! packet {
    ($testnet: expr, $packet_type: expr => $payload: expr) => {{
        let len = $payload.len();
        let mut packet: Vec<u8> = Vec::with_capacity(len + 24);
        if $testnet {
            let _ = 0xDAB5BFFAu32.encode(&mut packet);
        } else {
            let _ = 0xD9B4BEF9u32.encode(&mut packet);
        }
        // Write the message type
        if $packet_type.len() > 12 {
            let _ = $packet_type.as_bytes()[0..11].encode(&mut packet);
        } else {
            let _ = $packet_type.as_bytes().encode(&mut packet);
        }
        
        for _ in 1 .. (12-$packet_type.len()) {
          let _ = 0x00u8.encode(&mut packet);
        }
        let _ = 0x00u8.encode(&mut packet);
        // Write the length of the payload
        let _ = (len as u32).encode(&mut packet);

        // create a Sha256 object
        let mut hasher = Sha256::default();
        hasher.input(&$payload);
        let intermediate = hasher.result();
        let mut hasher = Sha256::default();
        hasher.input(&intermediate);
        let output = hasher.result();
        // write the checksum
        let _ = output[0..4].encode(&mut packet);
        // write the message payload
        let _ = $payload.encode(&mut packet);
        packet
    }};
    ($testnet: expr, $packet_type: expr, $packet: ident) => {{
        let mut packet_vec = Vec::with_capacity($packet.len());
        let _ = $packet.encode(&mut packet_vec);
        packet!($testnet, $packet_type => packet_vec)
    }};
    ($testnet: expr, $packet: ident) => {{
        let mut packet_vec = Vec::with_capacity($packet.len());
        let _ = $packet.encode(&mut packet_vec);
        packet!($testnet, $packet.name() => packet_vec)
    }};
    ($testnet: expr, $packet_type: expr) => {{
        packet!($testnet, $packet_type => vec![0;0])
    }}
}

impl Message {
    pub fn encode(&self, testnet: bool) -> Vec<u8> {
        match *self {
            // Empty message types
            Message::Verack => packet!(testnet, "verack"),
            Message::SendHeaders => packet!(testnet, "sendheaders"),
            Message::GetAddr => packet!(testnet, "getaddr"),
            
            // Simple Types
            Message::Ping(nonce) => {
                let mut v = Vec::with_capacity(8);
                let _ = nonce.encode(&mut v);
                packet!(testnet, "ping" => v)
            }
            Message::Pong(nonce) => {
                let mut v = Vec::with_capacity(8);
                let _ = nonce.encode(&mut v);
                packet!(testnet, "pong" => v)
            }
            Message::FeeFilter(filter) => {
                let mut v = Vec::with_capacity(8);
                let _ = filter.encode(&mut v);
                packet!(testnet, "feefilter" => v)
            },
            Message::BitcrustPeerCount(count) => {
                let mut v = Vec::with_capacity(8);
                let _ = count.encode(&mut v);
                packet!(testnet, "bcr_pc" => v)
            }

            // Complex Types
            Message::BitcrustPeerCountRequest(ref req) =>  packet!(testnet, req),
            Message::Version(ref message) => packet!(testnet, message),
            Message::GetData(ref msg) => packet!(testnet, msg), 
            Message::GetBlocks(ref msg) => packet!(testnet, msg),
            Message::GetHeaders(ref msg) => packet!(testnet, msg),
            Message::Addr(ref addr) => packet!(testnet, addr),
            Message::Inv(ref inv) => packet!(testnet, inv),
            Message::Header(ref headers) => packet!(testnet, headers),
            Message::SendCompact(ref message) => packet!(testnet, message),
            Message::Tx(ref tx) => packet!(testnet, tx),
            // Unparsed messages
            Message::Unparsed(_, ref v) => v.clone(),
        }
    }
}